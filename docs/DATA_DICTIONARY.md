# Data Dictionary / Словарь данных

**Beer Tap System** - Database Architecture Documentation  
**Version:** 2.0  
**Database Architect:** System Documentation  
**Date:** 2026-02-17

---

## Overview / Обзор

This document provides a comprehensive description of the Beer Tap System database schema. The system uses two different databases:

1. **PostgreSQL** - Central server database for production data
2. **SQLite** - Local controller database (RPi) for offline resilience

**Key Architectural Principles:**
- **UUID Generation:** All UUID primary keys are generated by the application using `default=uuid.uuid4`, NOT by the database
- **Separation of Concerns:** Reference data (Beverage) vs Instance data (Keg)
- **Immutability:** All transactions (Pour, Transaction) are immutable records
- **Audit Trail:** Complete audit logging through background tasks

---

## Core Tables / Основные таблицы

### beverages / Напитки

**Purpose:** Reference catalog of all drink types sold in the system.

| Column | Type | Description |
|--------|------|-------------|
| `beverage_id` | UUID (PK) | **Application-generated UUID** using `uuid.uuid4()`. Unique identifier for beverage type. |
| `name` | VARCHAR(100) UNIQUE | Human-readable name (e.g., "Heineken") |
| `brewery` | VARCHAR(100) | Manufacturer/brewery name |
| `style` | VARCHAR(50) | Beer style (e.g., "Lager", "IPA") |
| `abv` | DECIMAL(4,2) | Alcohol by volume percentage |
| `sell_price_per_liter` | DECIMAL(10,2) | Retail price per liter for customer billing |

**Relationships:**
- One-to-many with `kegs` (one beverage type can be in many kegs)

---

### kegs / Кеги

**Purpose:** Physical instances of beverage containers.

| Column | Type | Description |
|--------|------|-------------|
| `keg_id` | UUID (PK) | **Application-generated UUID** using `uuid.uuid4()`. Unique identifier for physical keg. |
| `beverage_id` | UUID (FK) | Links to `beverages.beverage_id` |
| `initial_volume_ml` | INTEGER | Starting volume in milliliters |
| `current_volume_ml` | INTEGER | Current remaining volume (updated after each pour) |
| `purchase_price` | DECIMAL(10,2) | Cost price of the entire keg |
| `status` | VARCHAR(20) | Finite state: `full`, `in_use`, `empty` |
| `tapped_at` | TIMESTAMPTZ | When keg was connected to tap |
| `finished_at` | TIMESTAMPTZ | When keg was emptied |
| `created_at` | TIMESTAMPTZ | Database server timestamp |

**Relationships:**
- Many-to-one with `beverages`
- One-to-one with `taps`
- One-to-many with `pours`

---

### taps / Краны

**Purpose:** Physical dispensing points in the bar.

| Column | Type | Description |
|--------|------|-------------|
| `tap_id` | INTEGER (PK) | Simple integer ID for physical tap identification |
| `keg_id` | UUID (FK) | Currently connected keg (nullable) |
| `display_name` | VARCHAR(50) | UI name (e.g., "Кран 1") |
| `status` | VARCHAR(20) | Finite state: `active`, `locked`, `cleaning`, `empty` |
| `last_cleaned_at` | TIMESTAMPTZ | Maintenance timestamp |

**Relationships:**
- One-to-one with `kegs`
- One-to-many with `pours`

---

### guests / Гости

**Purpose:** Customer information and accounts.

| Column | Type | Description |
|--------|------|-------------|
| `guest_id` | UUID (PK) | **Application-generated UUID** using `uuid.uuid4()`. Unique customer identifier. |
| `last_name` | VARCHAR(50) | Customer surname (indexed) |
| `first_name` | VARCHAR(50) | Customer given name |
| `patronymic` | VARCHAR(50) | Middle name (optional) |
| `phone_number` | VARCHAR(20) UNIQUE | Primary contact method |
| `date_of_birth` | DATE | For age verification |
| `id_document` | VARCHAR(100) | ID document number |
| `balance` | DECIMAL(10,2) | Current account balance |
| `is_active` | BOOLEAN | Account status flag |
| `created_at` | TIMESTAMPTZ | Database server timestamp |
| `updated_at` | TIMESTAMPTZ | Last modification timestamp |

**Relationships:**
- One-to-many with `cards`, `transactions`, `pours`

---

### cards / RFID-карты

**Purpose:** Physical RFID cards linked to customers.

| Column | Type | Description |
|--------|------|-------------|
| `card_uid` | VARCHAR(50) (PK) | RFID card UID read from scanner |
| `guest_id` | UUID (FK) | Linked customer |
| `status` | VARCHAR(20) | Card lifecycle: `active`, `inactive`, `lost` |
| `created_at` | TIMESTAMPTZ | Card registration timestamp |

**Relationships:**
- Many-to-one with `guests`
- One-to-many with `pours`

---

## Transaction Tables / Транзакционные таблицы

### pours / Наливы (CRITICAL TABLE)

**Purpose:** Immutable record of every dispense operation. This is the core transaction table.

| Column | Type | Description |
|--------|------|-------------|
| `pour_id` | UUID (PK) | **Application-generated UUID** using `uuid.uuid4()`. Unique transaction identifier. |
| `client_tx_id` | VARCHAR(100) UNIQUE | **Idempotency field**. Unique ID from RPi controller to prevent duplicate transactions during network failures. |
| `guest_id` | UUID (FK) | Customer who performed the pour |
| `card_uid` | VARCHAR(50) (FK) | RFID card used |
| `tap_id` | INTEGER (FK) | Physical tap used |
| `keg_id` | UUID (FK) | Source keg |
| `volume_ml` | INTEGER | Dispensed volume in milliliters |
| `amount_charged` | DECIMAL(10,2) | Total amount deducted from customer balance |
| `price_per_ml_at_pour` | DECIMAL(10,4) | **Financial snapshot**. Price per ml at moment of pour for historical accuracy |
| `poured_at` | TIMESTAMPTZ | Actual time of dispense (from controller) |
| `created_at` | TIMESTAMPTZ | Database insertion timestamp |

#### Key Field Explanations:

**`client_tx_id` (Idempotency):**
- Generated by RPi controller for each pour
- Prevents duplicate transactions during network interruptions
- Ensures "exactly-once" delivery semantics
- If same `client_tx_id` is received twice, second attempt is rejected

**`price_per_ml_at_pour` (Financial Snapshot):**
- Captures the exact price at time of pour
- Essential for historical financial reporting
- Allows price changes without affecting past transactions
- High precision (4 decimal places) for accurate calculations

**`attempts` (SQLite only):**
- **Exists only in SQLite database on RPi controller**
- Counts sync retry attempts to central server
- Prevents infinite retry loops for "poisoned messages"
- Not present in PostgreSQL schema

---

### transactions / Финансовые транзакции

**Purpose:** Financial operations (top-ups, refunds, corrections).

| Column | Type | Description |
|--------|------|-------------|
| `transaction_id` | UUID (PK) | **Application-generated UUID** using `uuid.uuid4()`. Unique financial transaction ID. |
| `guest_id` | UUID (FK) | Customer account |
| `amount` | DECIMAL(10,2) | Transaction amount (positive for top-up) |
| `type` | VARCHAR(20) | Operation type: `top-up`, `refund`, `correction` |
| `payment_method` | VARCHAR(20) | Payment method: `cash`, `card` |
| `created_at` | TIMESTAMPTZ | Transaction timestamp |

---

## System Tables / Системные таблицы

### audit_logs / Журнал аудита

**Purpose:** Complete audit trail of all administrative actions.

| Column | Type | Description |
|--------|------|-------------|
| `log_id` | UUID (PK) | **Application-generated UUID** using `uuid.uuid4()`. Unique audit entry ID. |
| `actor_id` | VARCHAR | User/system ID that performed the action |
| `action` | VARCHAR | Action type (e.g., "create_keg", "update_guest") |
| `target_entity` | VARCHAR | Entity type acted upon |
| `target_id` | VARCHAR | Specific entity ID |
| `details` | TEXT | JSON details of the action |
| `timestamp` | TIMESTAMPTZ | When action occurred |

#### AuditLog Mechanism:

**Background Task Creation:**
1. **Trigger:** In `security.py`, `get_current_user()` function intercepts all POST/PUT/DELETE requests
2. **Action Detection:** Constructs action string as `"{METHOD}_{PATH}"` (e.g., "POST_/api/kegs")
3. **Background Task:** Uses FastAPI's `BackgroundTasks.add_task()` to schedule audit logging
4. **Wrapper Function:** `audit_log_task_wrapper()` creates independent database session
5. **CRUD Operation:** Calls `audit_crud.create_audit_log_entry()` with full context
6. **Session Management:** Wrapper ensures proper session cleanup and error handling

**Key Benefits:**
- Non-blocking: API responses aren't delayed by audit logging
- Resilient: Audit failures don't affect main operations
- Independent: Uses separate DB session to avoid transaction conflicts
- Comprehensive: Captures all state-changing operations

---

### controllers / Контроллеры

**Purpose:** RPi device registration and status tracking.

| Column | Type | Description |
|--------|------|-------------|
| `controller_id` | VARCHAR(50) (PK) | Device self-identified ID (e.g., MAC address) |
| `ip_address` | VARCHAR(45) | Current network IP |
| `firmware_version` | VARCHAR(20) | Device firmware version |
| `created_at` | TIMESTAMPTZ | First registration time |
| `last_seen` | TIMESTAMPTZ | Last heartbeat/check-in |

---

### system_states / Состояния системы

**Purpose:** Key-value storage for global system flags.

| Column | Type | Description |
|--------|------|-------------|
| `key` | VARCHAR(50) (PK) | Configuration key (e.g., "emergency_stop_enabled") |
| `value` | VARCHAR(255) | Configuration value (e.g., "true", "false") |

---

## SQLite vs PostgreSQL Differences

### SQLite (RPi Controller) - Local Database

**Additional Fields in `pours` table:**
- `attempts` INTEGER DEFAULT 0 - Sync retry counter
- `status` TEXT DEFAULT 'new' - Sync status: `new`, `sent`, `confirmed`, `failed`
- `start_ts` TEXT - Pour start time
- `end_ts` TEXT - Pour end time
- `price_cents` INTEGER - Price in cents (integer arithmetic)

**Purpose:**
- Offline resilience during network outages
- Local queue for synchronization
- Retry logic with attempt counting

### PostgreSQL (Central Server) - Production Database

**Missing SQLite fields:**
- No `attempts` field (not needed server-side)
- No `status` field (transactions are final)
- No `start_ts`/`end_ts` (only `poured_at`)
- Uses `amount_charged` instead of `price_cents`

**Purpose:**
- Single source of truth for all business data
- Financial reporting and analytics
- Customer account management

---

## UUID Generation Strategy

**Critical Architecture Decision:** All UUID primary keys are generated by the Python application using `default=uuid.uuid4()`, NOT by the database.

**Why Application-Generated UUIDs:**
1. **Consistency:** Same generation method across PostgreSQL and SQLite
2. **Offline Capability:** RPi can generate UUIDs without network connectivity
3. **Predictability:** Application controls UUID generation logic
4. **Portability:** No database-specific UUID functions required

**Implementation:**
```python
# In models.py
import uuid

class Beverage(Base):
    beverage_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # ... other fields
```

---

## Index Strategy

**Performance-Critical Indexes:**
- `idx_pours_client_tx_id` - Prevents duplicate transactions (CRITICAL)
- `idx_pours_guest_id` - Customer pour history
- `idx_pours_tap_id` - Tap-specific analytics
- `idx_cards_guest_id` - Customer card lookup

**Business Impact:**
- Sub-millisecond duplicate transaction detection
- Fast customer history queries
- Real-time tap analytics
- Efficient card-to-customer resolution

---

## Data Integrity Constraints

**Foreign Key Relationships:**
- All foreign keys properly defined with appropriate constraints
- CASCADE deletes for dependent data (cards → guests)
- SET NULL for optional relationships (taps → kegs)

**Business Rules:**
- Unique constraints on customer identifiers (phone, email)
- Check constraints on enumerated fields (status values)
- Decimal precision for financial calculations
- Non-negative constraints on volumes and amounts

---

## Security Considerations

**Audit Trail:**
- Complete logging of all state-changing operations
- Background task processing prevents performance impact
- Immutable records with timestamps
- Actor identification for accountability

**Data Protection:**
- UUID primary keys prevent enumeration attacks
- Sensitive data properly indexed and constrained
- Financial data uses decimal precision for accuracy
- Audit logs stored separately from operational data

---

## Migration Strategy

**From SQLite to PostgreSQL:**
1. Data transformation required for field differences
2. UUID generation consistency maintained
3. Audit log preservation during migration
4. Index recreation for performance optimization

**Version Compatibility:**
- Schema versioning through Alembic migrations
- Backward compatibility considerations
- Data validation during upgrades
- Rollback procedures for critical changes
