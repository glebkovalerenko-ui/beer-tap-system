### **Основной документ**

#### `docs/phase-2-summary.md`

# Feature Reference & Implementation Summary — Phase 2: NFC и транзакции
*Дата завершения: 2025-10-18*

## 1. Overview

**Фаза 2** — это фундаментальный этап в разработке MVP **Beer Tap System**. Её главной целью было создание и тестирование сквозной интеграции, впервые объединившей **физический уровень** (NFC-карта и считыватель) с **цифровым ядром** (пользовательский интерфейс, бэкенд и база данных). Эта фаза стала первой настоящей проверкой всей архитектуры в действии.

**Ключевые реализованные сценарии:**

1.  **Чтение RFID-карты:** Успешная интеграция со считывателем ACR122 для надёжного получения уникального идентификатора (UID) карты.
2.  **Привязка карты к гостю:** Реализация бизнес-логики, позволяющей бармену привязать физическую карту к профилю гостя в системе.
3.  **Пополнение баланса:** Создание интерфейса и API для проведения финансовых транзакций по пополнению внутреннего баланса гостя.

**Результат:** По итогам фазы был успешно реализован и протестирован полный операционный цикл: **«Физическая карта → Идентификация гостя → Финансовая транзакция»**. Система доказала свою жизнеспособность, а архитектура — готовность к дальнейшему масштабированию.

---

## 2. Step 2.1 — NFC Integration

*   **Описание задачи:** Реализовать надёжный механизм чтения UID с RFID-карты в изолированном виде, создав переиспользуемый и отказоустойчивый компонент.

*   **Ключевые файлы и компоненты:**
    *   `src/components/modals/NFCModal.svelte`: Центральный UI-компонент, инкапсулирующий всю логику отображения состояний (ожидание, успех, ошибка).
    *   `src-tauri/src/nfc_handler.rs`: Новый Rust-модуль, в который была вынесена вся низкоуровневая логика взаимодействия с библиотекой `pcsc`.
    *   Событие `card-status-changed`: Вместо прямого вызова команды (`invoke`), фронтенд подписывается на события, которые Rust-бэкенд проактивно отправляет при изменении состояния карты.

*   **Техническая реализация:**
    *   **Архитектура:** Принята **событийно-ориентированная модель (Event-Driven)**. Фоновый Rust-поток непрерывно опрашивает NFC-считыватель и отправляет события (`emit`) в Svelte-часть при обнаружении/потере карты или ошибке. Это снижает нагрузку на UI и делает отклик мгновенным.
    *   **Обработка состояний:** `NFCModal` слушает события и на их основе управляет своим внутренним состоянием, отображая пользователю актуальную информацию.
    *   **Возврат UID:** При успешном считывании `NFCModal` генерирует Svelte-событие `on:uid-read`, передавая полученный UID родительскому компоненту.

*   **Критерии тестирования (✅ Выполнено):**
    *   [✅] `NFCModal` открывается и корректно отображает статусы "Ожидание", "Успех", "Ошибка".
    *   [✅] UID корректно считывается и передаётся в родительский компонент.
    *   [✅] Ошибки (отключение считывателя, быстрое извлечение карты) обрабатываются без паники приложения и отображаются в UI.

---

## 3. Step 2.2 — Card Binding (Привязка карты к гостю)

*   **Описание задачи:** Интегрировать разработанный NFC-модуль в бизнес-логику управления гостями.

*   **Ключевые изменения:**
    *   `GuestDetail.svelte`: Добавлена кнопка `+ Bind Card`, которая инициирует процесс.
    *   `Guests.svelte`: Компонент-оркестратор слушает событие от `GuestDetail`, открывает `NFCModal`, получает UID и вызывает Tauri-команду `bind_card_to_guest`.
    *   `guestStore.js`: Добавлен метод `bindCardToGuest`, который вызывает команду и применяет "оптимистичное обновление" UI после успешного ответа.

*   **Backend (FastAPI):**
    *   **Новый эндпоинт:** `POST /api/guests/{guest_id}/cards`.
    *   **Ключевое изменение логики:** Эндпоинт реализует паттерн **"Найди или Создай"**. Если карты с таким UID нет в базе, он её создаёт и сразу привязывает. Если есть, но свободна — привязывает. Если занята — возвращает ошибку. Это кардинально улучшило UX по сравнению с первоначальной двухшаговой логикой бэкенда.

*   **Критерии тестирования (✅ Выполнено):**
    *   [✅] Новая карта успешно создаётся в БД и привязывается к гостю, что мгновенно отражается в UI.
    *   [✅] Попытка привязать уже привязанную к другому гостю карту корректно возвращает ошибку `409 Conflict`, которая отображается пользователю.

---

## 4. Step 2.3 — Balance Top-up (Пополнение баланса)

*   **Описание задачи:** Реализовать полный цикл пополнения баланса гостя.

*   **Ключевые компоненты:**
    *   `src/components/modals/TopUpModal.svelte`: Новый, полностью инкапсулированный компонент с формой для ввода суммы.
    *   `GuestDetail.svelte`: Добавлена кнопка `+ Top Up` для вызова модального окна.
    *   Tauri-команда `top_up_balance`, которая вызывает `POST /api/guests/{guest_id}/topup`.
    *   `guestStore.js`: Добавлен метод `topUpBalance` с логикой "оптимистичного обновления".

*   **Backend (FastAPI):**
    *   **Эндпоинт:** `POST /api/guests/{guest_id}/topup` был реализован и протестирован.
    *   **Логика:** Создаёт запись в таблице `transactions` и атомарно обновляет поле `balance` в таблице `guests`.

*   **Критерии тестирования (✅ Выполнено):**
    *   [✅] После сохранения в модальном окне баланс гостя в `GuestDetail` обновляется мгновенно.
    *   [✅] Новая транзакция корректно создаётся в базе данных.
    *   [✅] Ввод некорректных данных (отрицательная сумма) обрабатывается на уровне UI.

---

## 5. Integration Flow Summary

Фаза 2 подтвердила работоспособность всей вертикали данных, от физического до визуального уровня.

**Схема потока данных при привязке карты:**
```
[ACR122 Reader] físico
       ↓
(Карта приложена)
       ↓
[Rust Background Thread] (main.rs) - опрашивает ридер
       ↓
`emit("card-status-changed", { uid: "..." })`
       ↓
[NFCModal.svelte] - слушает событие, показывает "Успех"
       ↓
`dispatch("uid-read", { uid: "..." })`
       ↓
[Guests.svelte] - получает UID, вызывает guestStore
       ↓
[guestStore.js] -> `invoke('bind_card_to_guest', ...)`
       ↓
[Tauri Command] (main.rs) - проксирует вызов
       ↓
[api_client.rs] -> `POST /api/guests/{id}/cards`
       ↓
[FastAPI Backend] (guests.py) - логика "Найди или Создай"
       ↓
[PostgreSQL] - сохранение данных
       ↓
[FastAPI Backend] - возвращает обновленный объект Guest
       ↓
[api_client.rs] -> [Tauri Command] -> [guestStore.js]
       ↓
[guestStore.js] - "оптимистично" обновляет массив гостей
       ↓
[GuestDetail.svelte] - Svelte-реактивность мгновенно показывает новую карту
```

---

## 6. Technical & Architectural Insights

*   **Событийная модель для NFC:** Подход с фоновым потоком в Rust, который проактивно отправляет события в UI, подтвердил свою эффективность. Он более производителен и отзывчив, чем постоянный опрос (`invoke`) из JavaScript.
*   **UX-Driven Backend:** Ключевой вывод фазы. Первоначальная логика бэкенда была неудобной для пользователя. Мы изменили API, чтобы он соответствовал интуитивно понятному рабочему процессу, а не заставлял пользователя подстраиваться под API.
*   **"Умные" модальные компоненты:** Паттерн, применённый в `NFCModal` (приём внешней ошибки через `prop` `externalError`), стал стандартом для обработки сложных сценариев, где ошибка может прийти с разных уровней.
*   **Реактивная загрузка данных:** Проблема с "пустым списком гостей" научила нас использовать реактивные блоки Svelte (`$:`) для запуска загрузки данных в ответ на изменение состояния (появление токена), что решает класс проблем с "состоянием гонки".
*   **Отказоустойчивость Rust:** Внедрение глобального обработчика паники (`panic hook`) сделало `admin-app` невосприимчивым к сбоям в низкоуровневых библиотеках, что является обязательным требованием для production-приложений.

---

## 7. Testing & Verification

*   **Интеграция NFC:** Тестирование проводилось на реальном оборудовании (ACR122, карты MIFARE Classic). Все сценарии (успешное чтение, быстрое извлечение карты, отключение ридера) были многократно проверены.
*   **Транзакции:** Сценарий пополнения баланса проверялся вручную с последующей проверкой UI. Успешное обновление баланса в `GuestDetail` служило подтверждением корректной работы всей цепочки.
*   **Обработка ошибок:** Специально тестировался сценарий привязки уже занятой карты, что подтвердило корректную работу защитной логики на бэкенде и отображение ошибки в UI.

---

## 8. Challenges & Fixes

*   **Паника в `pcsc`:** Изначально приложение падало при быстрых манипуляциях с картой. **Решение:** внедрение детального `match` для обработки ошибок и, в конечном итоге, глобального `panic hook` в `main.rs`.
*   **Расхождение логики Frontend ↔ Backend:** Frontend ожидал логику "привяжи карту", а Backend — "зарегистрируй, а потом привяжи". **Решение:** Полный рефакторинг API-эндпоинта на стороне FastAPI для реализации логики "найди или создай".
*   **Плохой UX при ошибках:** Одновременное отображение `NFCModal` с успехом и системного `alert` с ошибкой. **Решение:** Модификация `NFCModal` для приёма внешней ошибки, что позволило создать единый и понятный интерфейс для всех типов ошибок.
*   **"Состояние гонки" при загрузке данных:** Список гостей не загружался после логина. **Решение:** Замена `onMount` на реактивный блок `$: if ($sessionStore.token...)` в `Guests.svelte`.

---

## 9. Recommendations & Next Steps

*   **Что стоит улучшить:**
    *   **Централизованный Toaster/Notification Store:** Вместо `alert` и передачи ошибок через `props` можно создать глобальный `notificationStore`, который будет управлять очередью всплывающих уведомлений (успех/ошибка).
    *   **Детальное логирование:** Добавить логирование на бэкенде для всех успешных и неуспешных попыток привязки карт.
    *   **API для контроллера:** Начать проектирование эндпоинта, который RPi-контроллер сможет использовать для быстрой проверки статуса и баланса карты по её UID.
*   **Следующий шаг:** Проект полностью готов к началу **Фазы 3: Управление кегами и кранами**. Все ключевые риски, связанные с интеграцией оборудования и транзакциями, сняты.

---
---

### **Дополнительные отчёты**

#### `api_coverage_phase2.md`

| Эндпоинт | Метод | Покрытие клиентом | Примечание |
|---|---|---|---|
| `/api/guests/{guest_id}/cards` | `POST` | ✅ **Полное** | Реализовано и используется для привязки/регистрации карты. |
| `/api/guests/{guest_id}/topup` | `POST` | ✅ **Полное** | Реализовано и используется для пополнения баланса. |

#### `file_changes_phase2.md`

| Файл | Слой | Статус | Краткое описание изменений |
|---|---|---|---|
| `src-tauri/src/main.rs` | Frontend (Rust) | **Изменен** | Добавлены команды `bind_card_to_guest`, `top_up_balance`. Улучшена обработка ошибок в потоке. Добавлен `panic hook`. |
| `src-tauri/src/api_client.rs` | Frontend (Rust) | **Изменен** | Добавлены DTO `BindCardPayload`, `TopUpPayload` и функции для вызова соответствующих API. |
| `src-tauri/src/nfc_handler.rs` | Frontend (Rust) | **Новый** | Вся логика работы с `pcsc` вынесена в отдельный модуль. |
| `src/routes/Guests.svelte` | Frontend (Svelte) | **Изменен** | Добавлена оркестрация модальных окон `NFCModal` и `TopUpModal`. Загрузка данных переведена на реактивный блок. |
| `src/components/guests/GuestDetail.svelte`| Frontend (Svelte) | **Изменен** | Добавлены кнопки "Bind Card" и "Top Up", генерирующие события. |
| `src/stores/guestStore.js` | Frontend (Svelte) | **Изменен** | Добавлены методы `bindCardToGuest` и `topUpBalance` с "оптимистичным обновлением". |
| `src/components/modals/NFCModal.svelte` | Frontend (Svelte) | **Новый** | Создан компонент для управления процессом чтения NFC-карты. |
| `src/components/modals/TopUpModal.svelte` | Frontend (Svelte) | **Новый** | Создан компонент с формой для пополнения баланса. |
| `backend/api/guests.py` | Backend | **Изменен** | Переработан эндпоинт `POST .../cards` для реализации логики "найди или создай". |
| `backend/crud/card_crud.py` | Backend | **Изменен** | Добавлены вспомогательные функции `assign_card_to_guest` и `create_and_assign_card`. |

#### `technical_insights_phase2.md`

1.  **UX-Driven Backend Development:** Эта фаза стала ярким примером того, как потребности пользовательского интерфейса должны формировать API бэкенда. Исправление логики привязки карты с двухшаговой на одношаговую ("найди или создай") — ключевое архитектурное решение, которое значительно упростило код фронтенда и улучшило опыт конечного пользователя.

2.  **Надёжность через обработку паники:** В системах, взаимодействующих с внешним оборудованием и драйверами, сбои неизбежны. Вместо того чтобы пытаться предсказать каждую возможную ошибку, внедрение глобального `panic hook` в Rust-части приложения стало системным решением, которое гарантирует, что приложение останется в рабочем состоянии даже при самых неожиданных сбоях в `pcsc`.

3.  **Компонентная коммуникация в Svelte:** Мы отладили два паттерна:
    *   **События (`dispatch`):** Используются, когда дочерний компонент сообщает родителю о произошедшем действии (`NFCModal` → `on:uid-read`).
    *   **Props (`export let`):** Используются, когда родитель передаёт дочернему компоненту данные или принудительно изменяет его состояние (`Guests.svelte` → `NFCModal`, `externalError={...}`). Правильное сочетание этих двух механизмов является ключом к созданию чистого и предсказуемого UI.

4.  **Важность реактивности для SPA:** Проблема "пустого списка" после логина наглядно продемонстрировала фундаментальное отличие одностраничных приложений (SPA) от классических. `onMount` не является панацеей. Для данных, зависящих от асинхронных событий (таких как аутентификация), использование реактивных блоков (`$:`) является идиоматичным и единственно верным решением в Svelte.