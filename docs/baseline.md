### **Анализ исходных данных и предположения**

1.  **Использованные сообщения:** В качестве основы для этого документа были использованы все сообщения из нашего чата, включая:
    *   Первоначальный промпт с описанием концепции и требований.
    *   Сгенерированная дорожная карта из 6 этапов.
    *   Все итеративные инструкции для каждого из 6 этапов.
    *   Все отчеты пользователя о завершении этапов, включая финальные, исправленные и дополненные версии инструкций, кода и конфигураций.

2.  **Сделанные предположения:**
    *   **[ПРЕДПОЛОЖЕНИЕ] Оборудование для рабочего места бармена:** В чате не указана конкретная модель POS-терминала или принтера чеков. В BOM включены общие, популярные модели, совместимые со стандартными драйверами. *Причина: Необходимо для полноты BOM.*
    *   **[ПРЕДПОЛОЖЕНИЕ] Сетевое оборудование:** Предполагается использование стандартного Wi-Fi роутера для создания локальной сети. *Причина: Это наиболее распространенный и простой сценарий для локального развертывания.*
    *   **[ПРЕДПОЛОЖЕНИЕ] Физическая безопасность:** Вопросы физической защиты сервера (мини-ПК) и контроллеров от кражи или повреждения не обсуждались. Предполагается, что оборудование будет размещено в служебных помещениях. *Причина: Выходит за рамки программной части MVP.*

3.  **План дальнейших шагов для проверки документа:**
    1.  **Проверка на полноту:** Просмотрите "Исполнительное резюме" и `changelog.md`, чтобы убедиться, что все ключевые решения отражены.
    2.  **Техническая верификация:** Попросите коллегу-инженера следовать "Руководству быстрой настройки" (раздел H), чтобы проверить воспроизводимость развертывания с нуля.
    3.  **Утверждение бэклога:** Просмотрите "План работ и приоритеты" (раздел I), чтобы подтвердить или скорректировать следующие шаги для развития проекта после MVP.

---
### **Артефакт 1: `mvp-bar-exec-summary.md` (Исполнительное резюме)**
---

# Исполнительное резюме: MVP "Бар самообслуживания"
**Версия документа:** 1.0 | **Дата:** 2025-10-10

### **Описание проекта**
Аппаратно-программный комплекс для бара самообслуживания, позволяющий гостям самостоятельно наливать напитки с помощью RFID-карт с последующей оплатой в реальном времени.

### **Ключевые характеристики MVP**
1.  **Полная автономность:** Система спроектирована для работы в полностью офлайн-режиме в локальной сети бара, без зависимости от внешнего интернета.
2.  **Надежность и отказоустойчивость:** Контроллеры на Raspberry Pi ведут локальный журнал транзакций в SQLite (WAL), что гарантирует отсутствие потерь данных при обрывах связи с сервером.
3.  **Воспроизводимая среда:** Вся серверная часть (база данных, API, веб-интерфейс) упакована в Docker-контейнеры, что обеспечивает быстрый и предсказуемый запуск на любом оборудовании одной командой.
4.  **Современный технологический стек:**
    *   **Сервер:** Python/FastAPI, PostgreSQL, SQLAlchemy.
    *   **Контроллер:** Python, SQLite, Pyscard.
    *   **Интерфейс:** React, Vite, Nginx.
5.  **Готовый к пилоту функционал:** Реализован полный цикл: регистрация гостя, эмуляция налива на контроллере, автоматическая синхронизация транзакций с сервером и отображение данных в административной панели.

### **Текущий статус проекта**
**MVP полностью завершен.** Все 6 этапов дорожной карты пройдены. Система протестирована, задокументирована и приведена в состояние "боевой готовности" для пилотного запуска.

### **Основные риски и меры по их снижению**
*   **Риск:** Аппаратные сбои (SD-карта, питание).
    *   **Снижение:** Использование качественных компонентов, UPS для питания, отказоустойчивый режим WAL для SQLite.
*   **Риск:** Человеческий фактор (ошибки персонала).
    *   **Снижение:** Разработаны и включены в документацию подробные пошаговые инструкции (SOP) для барменов.

### **Следующие шаги**
1.  **Пилотный запуск:** Установка комплекса на одной-двух точках для сбора обратной связи в реальных условиях.
2.  **Интеграция с оборудованием:** Подключение физических счетчиков потока и клапанов вместо эмуляции.
3.  **Расширение UI:** Разработка интерфейса для пополнения баланса и управления кегами непосредственно барменом.

---
### **Артефакт 2: `mvp-bar-instruction_v1.0.md` (Основной документ)**
---
*(Далее следует полный текст основного Markdown-документа)*

# Инструкция по MVP проекта "Бар самообслуживания"
**Версия:** 1.0  
**Дата:** 2025-10-10  
**Автор сборки:** AI Assistant (Gemini) на основе чата с пользователем

### **Как использовать этот документ с ИИ-ассистентом**
Этот документ — ваш единый источник правды (Single Source of Truth) о проекте. При работе с другими ассистентами используйте его как основной контекст.

**Готовые под-промты для дальнейшей работы:**
1.  "Используя документ `mvp-bar-instruction_v1.0.md`, составь пошаговую инструкцию для инженера по сборке и настройке одного контроллерного стенда с нуля."
2.  "На основе раздела "План работ и приоритеты" (I) этого документа, создай спринт на 2 недели в формате Kanban-доски (колонки: Backlog, To Do, In Progress, Done)."
3.  "Используя раздел "Архитектура системы" (B), сгенерируй детальные тест-кейсы для проверки механизма идемпотентности при синхронизации."
4.  "На основе раздела D, напиши техническое задание для frontend-разработчика по реализации интерфейса пополнения баланса карты гостя."
5.  "Проанализируй раздел "Проблемы, найденные в ходе реализации" (G) и предложи превентивные меры мониторинга для каждого из пунктов."

## A. Введение
### Контекст и мотивация
Проект создан для автоматизации процесса розлива напитков в барах, пабах и на мероприятиях. Основная цель — сократить очереди, уменьшить нагрузку на персонал и предоставить гостям уникальный пользовательский опыт.

> **[ИСТОЧНИК]** Первоначальный промпт пользователя: "Проект — аппаратно-программный комплекс для бара самообслуживания: гостям выдают временные RFID-карты, по которым они сами наливают пиво из кранов, оплата списывается в реальном времени..."

### Цели MVP
1.  **Доказать жизнеспособность концепции:** Создать рабочий прототип, демонстрирующий полный цикл обслуживания.
2.  **Обеспечить надежность учета:** Гарантировать отсутствие потерь транзакций даже при сбоях сети.
3.  **Создать масштабируемый фундамент:** Заложить архитектуру, которую можно будет легко расширять.

### Кому предназначен документ
Этот документ предназначен для технических специалистов (разработчиков, инженеров), менеджеров проектов и других ИИ-ассистентов, которые будут вовлечены в дальнейшую разработку, поддержку или развертывание системы.

## B. Архитектура системы — обзор
### Общая блок-схема
Система состоит из двух основных частей: **локального сервера** и **контроллеров кранов**, работающих в одной локальной сети.

```mermaid
graph TD
    subgraph "Рабочее место бармена"
        AdminUI[Веб-интерфейс <br> (React, в браузере)]
    end

    subgraph "Локальный сервер (Мини-ПК в баре)"
        NGINX[Nginx <br> (Reverse Proxy)]
        API[Backend API <br> (FastAPI)]
        DB[(PostgreSQL)]
    end

    subgraph "Контроллер крана (Raspberry Pi)"
        ControllerApp[Python-приложение]
        LocalDB[(SQLite)]
        RFID[RFID-считыватель <br> (ACR122U)]
        FlowMeter((Счетчик потока <br> Эмулируется в MVP))
        Valve((Клапан <br> Эмулируется в MVP))
    end

    AdminUI -- HTTP-запросы --> NGINX
    NGINX -- /api --> API
    NGINX -- / --> AdminUI_Static
    API <--> DB
    ControllerApp -- HTTP Sync --> API
    ControllerApp <--> LocalDB
    ControllerApp <--> RFID
    ControllerApp --> Valve
    FlowMeter --> ControllerApp
```

### Описание потоков данных
1.  **Регистрация гостя:** Бармен через **AdminUI** отправляет данные на **API**. **API** сохраняет гостя в **PostgreSQL**.
2.  **Налив напитка:** Гость прикладывает карту к **RFID**-считывателю. **ControllerApp** проверяет карту (в MVP — только наличие). При эмуляции налива **ControllerApp** создает транзакцию (`client_tx_id`, объем, цена) и немедленно сохраняет ее в локальную **SQLite** со статусом `new`.
3.  **Офлайн-режим:** Если связь с сервером отсутствует, **ControllerApp** продолжает работать автономно, накапливая транзакции в **SQLite**.
4.  **Синхронизация:** В фоновом режиме **ControllerApp** периодически опрашивает **SQLite** на предмет записей со статусом `new`. Он формирует пачку данных и отправляет их на **API** (`/api/sync/pours`).
5.  **Обработка на сервере:** **API** принимает пачку. Для каждой транзакции оно проверяет уникальность `client_tx_id` (идемпотентность). Если транзакция уникальна, она сохраняется в **PostgreSQL**. Затем **API** возвращает контроллеру отчет об обработке.
6.  **Подтверждение:** **ControllerApp** получает ответ и обновляет статусы в **SQLite** на `confirmed` или `failed`.

## C. Оборудование (Hardware)
### Полный BOM
*(Полный BOM представлен в виде отдельного артефакта `mvp-bar-bom.csv`)*

| Компонент | Примерная модель | Назначение |
| :--- | :--- | :--- |
| Сервер | Mini PC Beelink / Intel NUC | Локальный сервер |
| Контроллер | Raspberry Pi 3B+ | Управление краном |
| Карта памяти | SanDisk Extreme 32GB A1 | ОС для RPi |
| RFID-считыватель | ACR122U-A9 | Чтение карт |
| RFID-карты | MIFARE Classic 1K | Карты гостя |
| Блок питания RPi| Official Raspberry Pi 5.1V 2.5A | Питание контроллера |
| **[ПРЕДПОЛОЖЕНИЕ]** Wi-Fi Роутер | TP-Link Archer C6 | Локальная сеть |

### Схемы подключения
На этапе MVP схема подключения минимальна:
1.  Мини-ПК (сервер) и Raspberry Pi (контроллер) подключены к одному Wi-Fi роутеру.
2.  Считыватель ACR122U подключен к USB-порту Raspberry Pi.
3.  На рабочем месте бармена используется любой ПК/ноутбук, подключенный к той же сети.

> **[ИСТОЧНИК]** Этап 3 инструкции: "Подключите RFID-считыватель ACR122U к USB-порту Raspberry Pi."

## D. Программная часть (Software)
### Описание серверной архитектуры
*   **Стек:** Debian (в Docker), PostgreSQL 15, Python 3.11, FastAPI, SQLAlchemy.
*   **Развертывание:** Вся серверная часть и фронтенд разворачиваются через `docker-compose`.

> **[ИСТОЧНИК]** Финальная версия инструкции Этапа 5: "Код для `docker-compose.yml` (ИСПРАВЛЕННЫЙ)".

**Ключевые файлы конфигурации:**
*   `docker-compose.yml` (см. Приложение)
*   `backend/Dockerfile` (см. Приложение)
*   `admin-ui/Dockerfile` (см. Приложение)
*   `nginx/nginx.conf` (см. Приложение)
*   `.env` (см. Приложение)

### Контроллерное ПО
*   **Стек:** Raspberry Pi OS Lite (64-bit), Python 3, SQLite, Pyscard.
*   **Ключевые библиотеки:** `pyscard`, `requests`.
*   **Запуск:** `python3 main_controller.py` из папки проекта.

> **[ИСТОЧНИК]** Финальная версия инструкции Этапа 3: "Установите Raspberry Pi OS Lite (64-bit)... установите Python-библиотеку `pyscard`".

**Ключевые файлы:**
*   `main_controller.py` (основной цикл, эмуляция)
*   `sync_client.py` (логика фоновой синхронизации)
*   `config.py` (конфигурация)

### Клиентское приложение (Админ-панель)
*   **Стек:** Node.js v22, React, Vite, Axios.
*   **Поведение:** Single Page Application (SPA) с маршрутизацией через `react-router-dom`.

> **[ИСТОЧНИК]** Финальная версия инструкции Этапа 5: "С помощью nvm установите и активируйте Node.js версии 22... npm create vite@latest admin-ui -- --template react".

## E. Безопасность и устойчивость
*   **Сетевая безопасность:** Вся система работает в изолированной локальной сети. Данные не выходят в интернет.
*   **Аутентификация:** На этапе MVP аутентификация пользователей и контроллеров отсутствует. Доступ к админ-панели не защищен.
*   **Защита при офлайне:** Гарантируется локальным журналом SQLite на контроллере и идемпотентным эндпоинтом синхронизации на сервере.
*   **Устойчивость при запуске:** "Гонка состояний" между бэкендом и БД решена с помощью механизма `healthcheck` в `docker-compose.yml`.

> **[ИСТОЧНИК]** Финальная версия инструкции Этапа 6: "Убедитесь, что ваш docker-compose.yml содержит `healthcheck` для базы данных... `depends_on: postgres: condition: service_healthy`".

## F. Тестирование и критерии приёмки
Полный чек-лист для сквозного тестирования находится в документе `docs/QA_Checklist.md`.

**Ключевые сценарии:**
1.  **"Счастливый путь":** Полный цикл от регистрации гостя до успешной синхронизации его налива.
2.  **Офлайн-режим:** Проверка накопления транзакций при отсутствии сети и их последующей успешной отправки.
3.  **Отказ сервера:** Проверка, что контроллер корректно обрабатывает недоступность сервера и повторяет попытки синхронизации.
4.  **Проверка ввода:** Попытки создать дубликаты или записи с некорректными данными через API.

**Критерии готовности MVP:** Успешное прохождение всех сценариев из `QA_Checklist.md`. Система развернута с "чистой" базы данных и готова к регистрации первого гостя.

## G. Проблемы, найденные в ходе реализации, и их решения
1.  **Проблема:** Ошибки CORS при запросах от локального dev-сервера фронтенда к API в Docker.
    *   **Проявление:** Ошибки в консоли браузера, блокировка запросов.
    *   **Решение:** Настройка `CORSMiddleware` в FastAPI для разрешения запросов со всех источников на этапе разработки.
    *   > **[ИСТОЧНИК]** Отчет пользователя, Этап 5: "Была отлажена двойная система конфигурации... CORS".

2.  **Проблема:** Ошибки `ImportError` в Python-бэкенде при запуске в Docker.
    *   **Проявление:** Контейнер `backend` не запускался.
    *   **Решение:** Замена всех относительных импортов (например, `from . import models`) на абсолютные (например, `import models`).
    *   > **[ИСТОЧНИК]** Финальная версия инструкции Этапа 5: "Исправление импортов Python: необходимо заменить все относительные импорты на абсолютные".

3.  **Проблема:** "Гонка состояний" при запуске `docker-compose`. Бэкенд пытался подключиться к БД до того, как она была готова.
    *   **Проявление:** Ошибки подключения к БД в логах `backend`, падение контейнера.
    *   **Решение:** Внедрение `healthcheck` для сервиса `postgres` и условия `condition: service_healthy` для `backend`.
    *   > **[ИСТОЧНИК]** Финальная версия инструкции Этапа 6: "Убедитесь, что ваш docker-compose.yml содержит `healthcheck`".

4.  **Проблема:** Сложности с установкой `pyscard` на Raspberry Pi.
    *   **Проявление:** Ошибки компиляции при `pip install`.
    *   **Решение:** Превентивная установка полного набора системных зависимостей, включая `python3-dev` и `swig`.
    *   > **[ИСТОЧНИК]** Финальная версия инструкции Этапа 3: "Установите полный набор системных библиотек... `python3-dev swig`".

## H. Руководство быстрой настройки (Quick Start)
1.  **Соберите оборудование:** Подключите Raspberry Pi и ACR122U согласно разделу C.
2.  **Настройте RPi:** Установите Raspberry Pi OS Lite, настройте SSH и выполните все шаги по установке зависимостей из финальной инструкции Этапа 3.
3.  **Клонируйте репозиторий:** `git clone <URL_РЕПОЗИТОРИЯ>` на ваш основной компьютер.
4.  **Настройте RPi:** Скопируйте папку `rpi-controller` на Raspberry Pi. В файле `config.py` укажите IP-адрес вашего основного компьютера.
5.  **Настройте сервер:** На основном компьютере создайте в корне проекта файл `.env` на основе примера.
6.  **Запустите Docker:** В корне проекта выполните `docker-compose up -d --build`.
7.  **Проверьте сервер:** Откройте в браузере `http://localhost/`. Вы должны увидеть админ-панель.
8.  **Запустите контроллер:** На RPi перейдите в папку проекта, активируйте `venv` и запустите `python3 main_controller.py`.
9.  **Выполните первый тест:** Зарегистрируйте гостя через UI, затем приложите карту к RPi и эмулируйте налив. Убедитесь, что транзакция появилась в БД сервера.

## I. План работ и приоритеты (Backlog после MVP)
| Приоритет | Задача | Описание | Роль |
| :--- | :--- | :--- | :--- |
| **Высокий** | UI для пополнения баланса | Реализовать в админ-панели функционал пополнения баланса карты гостя. | Frontend |
| **Высокий** | Интеграция с Flow Meter | Написать код на RPi для чтения данных с импульсного счетчика потока. | Backend (RPi) |
| **Средний** | Управление кегами в UI | Добавить в админ-панель раздел для назначения сортов пива на краны. | Frontend |
| **Средний** | Повышение безопасности карт | Внедрить ECDSA-подпись для защиты данных, записываемых на карту. | Backend (Server+RPi) |
| **Низкий** | Отчетность | Создать базовые отчеты о продажах за смену в админ-панели. | Frontend, Backend |

## J. Приложения
*(В этом разделе должны быть полные тексты файлов, но для краткости здесь приведены ссылки)*

1.  **BOM:** См. файл `mvp-bar-bom.csv`.
2.  **Changelog:** См. файл `changelog.md`.
3.  **Metadata:** См. файл `mvp-bar-metadata.json`.
4.  **Диаграммы:** См. файл `diagrams/architecture.svg`.
5.  **Полные конфигурационные файлы:** (Dockerfile, docker-compose.yml, .env, nginx.conf)
6.  **Полные SQL-схемы:** (postgres_schema.sql, sqlite_schema.sql)

---
### **Артефакт 3: `mvp-bar-bom.csv`**
---
```csv
Component,Model/Example,Purpose,Notes
Server,"Mini PC Beelink / Intel NUC",Local server for API and DB,"[ПРЕДПОЛОЖЕНИЕ] Конкретная модель не выбрана"
Controller,"Raspberry Pi 3B+",Tap controller
Memory Card,"SanDisk Extreme 32GB A1",OS for Raspberry Pi,"Class 10 / A1 recommended for reliability"
RFID Reader,"ACR122U-A9",Guest card reader,"Proven to work with pyscard"
RFID Cards,"MIFARE Classic 1K",Guest cards,"Standard 13.56 MHz cards"
RPi Power Supply,"Official Raspberry Pi 5.1V 2.5A",Power for controller,"Stable power is critical"
Network Router,"TP-Link Archer C6 / Keenetic",Local Area Network,"[ПРЕДПОЛОЖЕНИЕ] Any modern router"
Bartender Workstation,"Any modern PC/Laptop",Admin UI access,""
```
---
### **Артефакт 4: `mvp-bar-metadata.json`**
---
```json
{
  "project_name": "Beer Tap System MVP",
  "document_version": "1.0",
  "generation_date": "2025-10-10",
  "authors": [
    "User",
    "AI Assistant (Gemini)"
  ],
  "source_chat_summary": "Based on a continuous conversation covering project inception, a 6-stage development roadmap, and iterative implementation with user feedback and corrections.",
  "key_technologies": {
    "backend": "Python, FastAPI, PostgreSQL, SQLAlchemy",
    "frontend": "React, Vite, Nginx",
    "controller": "Python, SQLite, Pyscard",
    "deployment": "Docker, Docker Compose"
  }
}
```
---
### **Артефакт 5: `changelog.md`**
---
# Changelog решений проекта "Бар самообслуживания"

### **Этап 1: Фундамент**
*   **Решение:** Принята структура проекта с разделением на `backend`, `admin-ui`, `rpi-controller`.
*   **Решение:** Выбраны PostgreSQL для сервера и SQLite для контроллера.
*   **Решение:** Схемы данных доработаны для атомарности (`full_name` -> `first_name`, `last_name`) и аналитики (`purchase_price` в кегах).

### **Этап 2: Бэкенд API**
*   **Решение:** Выбран стек FastAPI + SQLAlchemy + Pydantic за скорость, авто-документацию и валидацию.
*   **Решение:** Для финансовых расчетов в БД решено использовать тип `Decimal` (реализовано в модели `Guest`).
*   **Проблема/Решение:** Обнаружена и решена проблема CORS путем добавления `CORSMiddleware` в FastAPI.

### **Этап 3: Контроллер RPi**
*   **Решение:** Выбран Raspberry Pi 3B+ и считыватель ACR122U.
*   **Решение:** Для работы с RFID используется библиотека `pyscard`.
*   **Проблема/Решение:** Решены проблемы с установкой `pyscard` путем превентивной установки `python3-dev` и `swig`.
*   **Проблема/Решение:** Реализована отказоустойчивая логика основного цикла с корректной обработкой `NoCardException` и `CardConnectionException`.

### **Этап 4: Синхронизация**
*   **Решение:** Реализован механизм фоновой синхронизации на контроллере с использованием `threading`.
*   **Решение:** На сервере реализован идемпотентный эндпоинт, проверяющий уникальность `client_tx_id`.

### **Этап 5: Админ-панель**
*   **Решение:** Выбран стек React + Vite + Node.js v22 за современность и скорость разработки.
*   **Проблема/Решение:** Решены проблемы с путями и импортами при сборке в Docker. `Dockerfile` и `docker-compose.yml` были полностью переработаны до рабочей версии.
*   **Решение:** Nginx используется как единая точка входа, проксирующая запросы к API и раздающая статику фронтенда.

### **Этап 6: Сборка и тесты**
*   **Решение:** Разработан формализованный QA-чеклист и SOP для персонала.
*   **Проблема/Решение:** Решена проблема "гонки состояний" при запуске Docker с помощью `healthcheck` для PostgreSQL.
*   **Решение:** Определена процедура "холодного старта" с очисткой томов для подготовки к пилотному запуску.