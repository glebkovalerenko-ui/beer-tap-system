# Phase 2.5 — Safe Refactor Plan (No Rewrite)

## Current codebase reuse analysis

## 1) Reuse as-is

- Tauri command layer and backend contracts (`src-tauri/src/main.rs`, `api_client.rs`).
- Store-based data access pattern (`guestStore`, `tapStore`, `kegStore`, `systemStore`, `pourStore`).
- Existing feedback infrastructure (`ToastContainer`, `ConfirmDialog`, `uiStore`).
- Existing NFC event path (`nfcReaderStore`, `NFCModal`) with graceful failure messages.
- Existing route skeleton (`Dashboard`, `Guests`, `TapsKegs`, `Login`) and auth gate in `App.svelte`.

## 2) Refactor (incremental)

- `App.svelte` shell: convert sidebar-first test layout into POS workspace shell while preserving routes.
- `Guests.svelte` + guest components: shift from CRUD-heavy list/detail split to operation-first guest context.
- `TopUpModal.svelte`: evolve into robust amount-input experience (presets + keypad + validation states).
- `GuestDetail.svelte`: promote balance/history/action layout with one primary CTA.
- Token usage: replace ad-hoc colors/spacing with `tokens.css` gradually.

## 3) Must NOT be touched (Phase 3 safety)

- Tauri command names/signatures.
- Backend endpoint contracts and payload schema.
- Routing library migration (no router replacement).
- Global auth persistence behavior (`sessionStore` token key semantics) unless explicitly required.

## 4) Highest regression risk

1. Auth/session gating in `App.svelte` (risk of app-lockout if shell refactor breaks token branch).
2. Guest operations chain (`create_guest`, `bind_card_to_guest`, `top_up_balance`) where UX refactor may alter event wiring.
3. NFC modal/listener lifecycle (duplicate listeners, stale close timers).
4. System polling and emergency stop controls (unintended side effects from layout moves).

## 5) Shell-level vs component-level changes

## Shell-level
- `App.svelte` layout and persistent status bar.
- Route-level composition (which panes appear on each route).
- Global notifications and fallback banners.

## Component-level
- Guest context cards, action panels, amount keypad UI.
- Empty/error states.
- Status pills and standardized buttons/cards/inputs.

---

## Minimal invasive restructuring strategy

## Phase S1: Wrap, don’t rewrite
- Introduce new shell containers/classes around existing content.
- Keep existing route components mounted and functional.
- Avoid deleting legacy blocks until replacement validated.

## Phase S2: Migrate flow-by-flow
- Migrate one core flow at a time (Guest context -> Top-up -> Balance/history -> Shift).
- Preserve old action handlers initially; replace UI surfaces first, logic second.

## Phase S3: Consolidate styles
- Map existing style rules to semantic tokens.
- Remove duplicated local styles only after visual parity checks.

## Phase S4: Risk hardening
- Add guardrails for loading, disabled, and timeout states.
- Keep failure paths explicit with non-technical messages.

---

## Incremental migration plan (reversible)

1. Add `POSShell` layout wrappers and status chips in `App.svelte`.
2. Add `GuestContextPanel` while keeping existing `Guests` list/detail alive.
3. Upgrade top-up UI component but keep current `guestStore.topUpBalance` call.
4. Add unified balance/history block in guest detail route.
5. Add shift panel with local/demo-safe fallback (no contract changes).
6. Final pass: token alignment and consistent component states.

Rollback rule: each step can be reverted by removing newly introduced wrapper/components without touching Tauri/backend integration.

---

## Regression prevention checklist

- Login/logout still works in web + tauri runtime.
- Existing routes still accessible (`#/`, `#/guests`, `#/taps-kegs`).
- Guest create/edit/top-up still callable end-to-end.
- NFC modal still opens, receives event, and closes correctly.
- System status polling still updates emergency state.
- Build stays green after each milestone.
